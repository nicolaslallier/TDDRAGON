# Documentation – Plateforme v0.1.0 (Nginx + PostgreSQL)

- **Nom du système** : (à définir) – Plateforme applicative  
- **Version** : `v0.1.0`  
- **Architecture cible (simplifiée)** :  
  - Nginx (reverse proxy / front-end HTTP)  
  - Application (API / Web app légère)  
  - Base de données PostgreSQL (non exposée, réseau interne seulement)

---

## 0. Hypothèses (Assumptions)

1. Il existe **une application backend** derrière Nginx utilisant PostgreSQL.
2. PostgreSQL n’est **pas exposé directement à Internet** (accessible uniquement par l’application).
3. v0.1.0 est un **MVP technique** (pas de haute dispo, ni de scalabilité avancée).
4. Un seul environnement cible au départ (ex. DEV ou TST).

---

## 1. Contexte & Objectifs (Context & Goals)

### 1.1 Contexte / Context

- Mise en place d’une **première version technique** de la plateforme.
- Stack :
  - Nginx comme **reverse proxy**.
  - Application backend derrière Nginx.
  - PostgreSQL comme base de données relationnelle.
- Objectif : disposer d’un **socle minimal propre et reproductible** pour les futurs développements fonctionnels.

### 1.2 Problème / Problem

- Absence de plateforme standardisée avec :
  - Point d’entrée unique HTTP(S).
  - Séparation claire entre **front / logique métier / persistance**.
- Besoin d’un environnement technique simplifié pour :
  - Tester la connectivité.
  - Valider des patterns d’accès.
  - Préparer l’arrivée des fonctionnalités métier.

### 1.3 Objectifs / Goals

- Mettre en place un **MVP d’architecture** :
  - Application accessible via Nginx.
  - PostgreSQL configuré de manière sécurisée.
- Fournir une **documentation claire** pour PM, PO, architectes, devs, QA.
- Permettre des **tests techniques de bout en bout** (client → Nginx → app → PostgreSQL).

### 1.4 Périmètre / Scope v0.1.0

**Inclus (In Scope)**

- Nginx comme **reverse proxy** HTTP/HTTPS.
- Application backend simple avec :
  - Endpoint de santé (`/health` ou `/status`).
  - Endpoints de test utilisant PostgreSQL.
- Instance PostgreSQL accessible uniquement depuis l’application.
- Logging minimal (Nginx + application).

**Exclus (Out of Scope)**

- Haute disponibilité (cluster PG, Nginx multi-nœuds).
- Mécanismes avancés de sécurité (WAF, IAM complexe).
- Monitoring avancé (dashboards, alertes).
- Fonctionnalités métier complexes.

---

## 2. Parties prenantes / Stakeholders

- **Sponsor / Stakeholder exécutif** : valide le périmètre et les objectifs.
- **Product Owner (PO)** : priorise l’évolution fonctionnelle future.
- **Architecte de solution / d’entreprise** : définit les patterns d’architecture.
- **DevOps / Infra** : déploie Nginx, PostgreSQL, réseaux, scripts de déploiement.
- **Développeurs backend** : implémentent l’application consommant PostgreSQL.
- **Testeurs / QA** : définissent et exécutent les tests d’acceptation.

---

## 3. Processus & Scénarios (BPMN-like)

### 3.1 Processus principal – Consultation de l’API via Nginx

**Vue BPMN textuelle**

> Start → Requête HTTP client → Nginx reçoit la requête → Nginx route vers l’application →  
> Application traite la requête → Application lit/écrit dans PostgreSQL → Application renvoie la réponse à Nginx →  
> Nginx renvoie la réponse au client → End

**Étapes détaillées**

1. **Start** – Un client (navigateur, outil API, autre service) envoie une requête HTTP(S).
2. Nginx reçoit la requête sur `http(s)://<host>/...`.
3. Nginx applique les règles de routage (host / path) et transfère la requête à l’application backend.
4. L’application reçoit la requête, valide les paramètres, exécute la logique métier.
5. L’application se connecte à PostgreSQL (pool de connexions) si une opération de lecture/écriture est requise.
6. PostgreSQL exécute la requête SQL et retourne le résultat à l’application.
7. L’application formate la réponse (JSON / HTML) et la renvoie à Nginx.
8. Nginx transmet la réponse au client.
9. **End** – Le client reçoit la réponse (2xx, 4xx ou 5xx).

---

## 4. Exigences fonctionnelles (Functional Requirements)

> Notation : **FR-XXX – Exigence / Requirement**

### 4.1 Accès via Nginx

- **FR-001** – Le système doit exposer un point d’entrée HTTP/HTTPS unique via Nginx pour toutes les requêtes client.
- **FR-002** – Nginx doit router les requêtes entrantes vers l’application backend selon l’URL (host et/ou path).
- **FR-003** – Le backend doit exposer au minimum une route de santé (`/health` ou `/status`) indiquant l’état de l’application.
- **FR-004** – Le backend doit fournir au moins un endpoint permettant de tester une opération simple de lecture/écriture sur PostgreSQL.

### 4.2 Connexion à PostgreSQL

- **FR-005** – L’application doit se connecter à PostgreSQL à l’aide d’une chaîne de connexion configurable (host, port, database, username, password).
- **FR-006** – L’application doit pouvoir créer et gérer une table de test (ex. `demo_items`) avec un identifiant unique et un champ texte.
- **FR-007** – L’application doit fournir un endpoint `POST` permettant de créer un enregistrement dans la table de test.
- **FR-008** – L’application doit fournir un endpoint `GET` permettant de lire les enregistrements de la table de test.

### 4.3 Journalisation / Logging

- **FR-009** – Nginx doit journaliser les requêtes entrantes (date/heure, IP, méthode, URI, code HTTP).
- **FR-010** – L’application doit journaliser les erreurs applicatives (stack trace ou message d’erreur exploitable).

---

## 5. Exigences non fonctionnelles (NFRs)

> Notation : **NFR-XXX – Non-Functional Requirement**

### 5.1 Performance & Disponibilité

- **NFR-001** – Le système doit supporter au minimum 10 requêtes/seconde sans erreur dans un environnement de test.
- **NFR-002** – Le temps de réponse de la route `/health` doit être ≤ 500 ms pour 95 % des requêtes (charge normale de test).

### 5.2 Sécurité & Accès

- **NFR-003** – PostgreSQL ne doit pas être accessible depuis Internet (aucun port DB exposé publiquement).
- **NFR-004** – Les identifiants PostgreSQL ne doivent pas être hard-codés dans le code ; ils doivent être injectés via variables d’environnement ou fichiers de configuration sécurisés.
- **NFR-005** – Si HTTPS est activé, les certificats TLS doivent être gérés par Nginx (auto-signés ou officiels, selon l’environnement).

### 5.3 Observabilité & Maintenance

- **NFR-006** – Les logs Nginx et applicatifs doivent inclure au minimum : timestamp, méthode HTTP, URI, code HTTP, message d’erreur le cas échéant.
- **NFR-007** – Le déploiement doit être reproductible (script, docker-compose, chart, etc., à préciser).

---

## 6. Règles d’affaires / Règles techniques

> Notation : **BR-XXX – Business/Technical Rule**

- **BR-001** – Toute requête vers l’application backend doit passer par Nginx (pas d’accès direct externe au port applicatif).
- **BR-002** – PostgreSQL ne doit accepter des connexions que depuis le réseau interne (subnet applicatif / réseau de containers).
- **BR-003** – Pour v0.1.0, un seul schéma PostgreSQL est utilisé (ex. `public`), sauf décision explicite de l’architecte.
- **BR-004** – Les modifications de schéma (DDL) doivent être versionnées (scripts SQL ou outil de migration type Flyway/Liquibase).

---

## 7. Données & Modèle d’information

### 7.1 Entité de test : `demo_items`

- **Table** : `demo_items`
- **Champs** (exemple) :
  - `id` – `SERIAL` ou `UUID`, clé primaire, non nul.
  - `label` – `VARCHAR(255)`, non nul.
  - `created_at` – `TIMESTAMP`, non nul, défaut `NOW()`.

### 7.2 Considérations

- Données de v0.1.0 : principalement **données de test**, pas de PII prévue.
- Les données peuvent être purgées régulièrement (aucune exigence de rétention stricte pour v0.1.0).

---

## 8. Cas de tests d’acceptation (Acceptance Criteria)

> Notation : **AT-XXX – Acceptance Test**

### 8.1 Test – Route de santé

- **AT-001 – Health Check**
  - **Étant donné** que Nginx et l’application sont démarrés,  
  - **Lorsque** le client appelle `GET /health` (ou `/status`) via Nginx,  
  - **Alors** la réponse doit être `200 OK` avec un payload indiquant que le service est “UP”.

### 8.2 Test – Création d’un enregistrement

- **AT-002 – Création**
  - **Étant donné** que PostgreSQL est accessible et que la table `demo_items` existe,  
  - **Lorsque** le client appelle `POST /demo-items` avec un `label` valide,  
  - **Alors** un enregistrement est créé dans PostgreSQL,  
  - **Et** la réponse contient l’`id` généré et le `label`,  
  - **Et** le code HTTP est `201 Created`.

### 8.3 Test – Lecture des enregistrements

- **AT-003 – Lecture**
  - **Étant donné** qu’au moins un `demo_item` existe,  
  - **Lorsque** le client appelle `GET /demo-items`,  
  - **Alors** la réponse retourne la liste des éléments,  
  - **Et** le code HTTP est `200 OK`.

### 8.4 Test – Protection PostgreSQL

- **AT-004 – Non-exposition DB**
  - **Étant donné** un client externe sur Internet,  
  - **Lorsque** il tente de se connecter directement au port PostgreSQL,  
  - **Alors** la connexion doit échouer (port fermé ou filtré).

---

## 9. Risques, dépendances & questions ouvertes

### 9.1 Risques

- **R-001** – Sous-estimation de la complexité réseau (firewall, security groups) pouvant retarder la mise en service.
- **R-002** – Manque de monitoring minimal rendant le diagnostic d’incidents difficile.
- **R-003** – Risque de dérive de scope si trop de logique métier est ajoutée en v0.1.0.

### 9.2 Dépendances

- Disponibilité des ressources infra (VM, containers, cluster, etc.).
- Choix et mise en place des outils de déploiement (docker-compose, Kubernetes, etc.).
- Décision sur la gestion des secrets (Vault, Key Vault, variables d’environnement…).

### 9.3 Questions ouvertes

1. Environnement(s) cible(s) pour v0.1.0 : **DEV seulement** ou aussi **TST** ?  
2. L’application backend sera-t-elle uniquement **API REST** ou inclura-t-elle une UI web ?  
3. Souhaite-t-on activer **HTTPS dès v0.1.0** (certificats nécessaires) ?  
4. Veut-on intégrer un **outil de migration de schéma** dès cette version (Flyway, Liquibase) ?  
5. Existe-t-il des **contraintes de conformité** applicables même pour les données de test ?

---